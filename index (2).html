<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Local Leads Map — Visionary Web Forge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html, body, #root { height: 100%; }
      .tick-group label { display:flex; align-items:center; gap:.5rem; cursor:pointer; user-select:none; }
      .tick-radio { appearance:none; -webkit-appearance:none; width:0; height:0; position:absolute; opacity:0; }
      .tick-box { width:14px; height:14px; border-radius:9999px; border:2px solid #6b7280; display:inline-grid; place-items:center; transition:all .15s ease; background:white; }
      .tick-radio:checked + .tick-box { background:#111827; border-color:#111827; }
      .tick-box::after { content:""; width:8px; height:8px; display:block; }
      .tick-radio:checked + .tick-box::after { content:"✓"; color:white; font-size:10px; line-height:8px; }
      .chip { font-size:10px; padding:2px 6px; border-radius:9999px; border:1px solid #e5e7eb; background:#f9fafb; }
      .btn { padding:.4rem .7rem; border:1px solid #e5e7eb; border-radius:.5rem; font-size:.85rem; }
      .btn-primary { background:black; color:white; }
      .card { border:1px solid #e5e7eb; border-radius:.75rem; padding:.5rem; }
      .stat { display:flex; align-items:center; justify-content:space-between; font-size:.75rem; padding:.25rem .5rem; border:1px solid #eef2f7; border-radius:.5rem; }
      .section-title { font-size:.8rem; font-weight:600; margin:.75rem 0 .4rem; }
    </style>
  </head>
  <body class="bg-white">
    <div id="root"></div>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBYk3qNJiOzbCdcrH_mjpgnJuS_aA1-Vls&libraries=places"></script>
    <script type="module">
      import { html, render, useState, useEffect, useRef } from 'https://unpkg.com/htm/preact/standalone.module.js';

      const TYPE_COLORS = {
        restaurant:"#ef4444", bar:"#f97316", cafe:"#f59e0b", bakery:"#eab308",
        store:"#3b82f6", clothing_store:"#8b5cf6", shoe_store:"#d946ef",
        electronics_store:"#22c55e", furniture_store:"#14b8a6", jewelry_store:"#ca8a04",
        book_store:"#0ea5e9", pet_store:"#84cc16", supermarket:"#22c55e",
        beauty_salon:"#db2777", gym:"#06b6d4", real_estate_agency:"#0ea5e9",
        car_dealer:"#f97316", bicycle_store:"#10b981", hardware_store:"#4b5563",
        florist:"#f43f5e", pharmacy:"#a855f7", spa:"#60a5fa", lodging:"#10b981",
        _closed_temp:"#9ca3af", _closed_perm:"#374151", _unknown:"#6b7280",
      };
      const LEAD_STATUS_LABEL = {
        todo:"Da contattare",
        appointment:"Appuntamento",
        proposal_sent:"Preventivo richiesto/inviato",
        quote_rejected:"Preventivo rifiutato",
        in_progress:"In lavorazione",
        won:"Cliente acquisito",
        not_needed:"Non necessario",
        not_interested:"Non lo vuole",
        done:"Svolto",
      };
      const LEAD_STATUS_COLOR = {
        todo:"#f59e0b", appointment:"#3b82f6", proposal_sent:"#a855f7", quote_rejected:"#fb923c",
        in_progress:"#14b8a6", won:"#16a34a", not_needed:"#9ca3af", not_interested:"#ef4444", done:"#10b981",
      };
      const PROSPECT_TYPES = [
        { value: "restaurant", label: "Ristoranti" },
        { value: "cafe", label: "Bar e Caffè" },
        { value: "bakery", label: "Panetterie / Pasticcerie" },
        { value: "clothing_store", label: "Negozi di abbigliamento" },
        { value: "shoe_store", label: "Calzature" },
        { value: "electronics_store", label: "Elettronica" },
        { value: "furniture_store", label: "Arredamento" },
        { value: "jewelry_store", label: "Gioiellerie" },
        { value: "book_store", label: "Librerie" },
        { value: "pet_store", label: "Negozi per animali" },
        { value: "supermarket", label: "Supermercati / Alimentari" },
        { value: "beauty_salon", label: "Parrucchieri / Beauty" },
        { value: "gym", label: "Palestre" },
        { value: "real_estate_agency", label: "Agenzie Immobiliari" },
        { value: "car_dealer", label: "Concessionarie" },
        { value: "bicycle_store", label: "Negozi di bici" },
        { value: "hardware_store", label: "Ferramenta" },
        { value: "florist", label: "Fiorai" },
        { value: "pharmacy", label: "Farmacie / Parafarmacie" },
        { value: "spa", label: "Spa / Centri benessere" },
        { value: "lodging", label: "Hotel / B&B" },
      ];

      const LS_KEY = "leadNotesByPlaceId_v8";
      const loadNotes = ()=>{ try{ const raw=localStorage.getItem(LS_KEY); const p=raw?JSON.parse(raw):{}; for (const k in p){ p[k].status??="todo"; p[k].flagged??=false; p[k].note??=""; } return p;}catch{return{}} };
      const saveNotes = (obj)=>{ try{ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }catch(e){ console.warn(e);} };

      // Google helpers
      const createIcon = (color)=> ({ path: google.maps.SymbolPath.CIRCLE, scale:10, fillColor:color, fillOpacity:1, strokeColor:"#111827", strokeOpacity:1, strokeWeight:2 });
      const statusToLabel = (s)=> s===google.maps.places.BusinessStatus.OPERATIONAL ? "Operativa" :
                               s===google.maps.places.BusinessStatus.CLOSED_TEMPORARILY ? "Chiuso temporaneamente" :
                               s===google.maps.places.BusinessStatus.CLOSED_PERMANENTLY ? "Chiuso definitivamente" : "Stato sconosciuto";
      function getPlaceColor(place, mainType, leadStatus){
        if (leadStatus) return LEAD_STATUS_COLOR[leadStatus];
        const s = place.business_status;
        if (s === google.maps.places.BusinessStatus.CLOSED_PERMANENTLY) return TYPE_COLORS._closed_perm;
        if (s === google.maps.places.BusinessStatus.CLOSED_TEMPORARILY) return TYPE_COLORS._closed_temp;
        return TYPE_COLORS[mainType] || TYPE_COLORS._unknown;
      }

      // Messaging
      const cleanPhoneForWa = (phone)=> (phone||"").replace(/[^\d+]/g,"").replace(/^\+/,"");
      const buildWhatsAppLink = (phone, text)=>{
        const p = cleanPhoneForWa(phone);
        const enc = encodeURIComponent(text);
        return p ? `https://wa.me/${p}?text=${enc}` : `https://wa.me/?text=${enc}`;
      };
      const buildMailtoLink = (email, subject, body)=> `mailto:${email||""}?subject=${encodeURIComponent(subject||"")}&body=${encodeURIComponent(body||"")}`;

      function App(){
        const mapRef = useRef(null);
        const map = useRef(null);
        const placesSvc = useRef(null);
        const infoRef = useRef(null);
        const markersRef = useRef({});
        const placeIndexRef = useRef({});
        const centerMarker = useRef(null);
        const circleRef = useRef(null);
        const fileInputRef = useRef(null);

        // NEW: meta per sito web
        const placeMetaRef = useRef({}); // { [placeId]: { hasWebsite: true|false|null } }

        const [center, setCenter] = useState(null);
        const [radius, setRadius] = useState(1500);
        const [query, setQuery] = useState("");
        const [missingOnly, setMissingOnly] = useState(false);
        const [onlyPotential, setOnlyPotential] = useState(false);
        const [selectedType, setSelectedType] = useState("all");
        const [results, setResults] = useState([]);
        const [notes, setNotes] = useState({});
        const [loading, setLoading] = useState(true);
        const [fetching, setFetching] = useState(false);
        const [clickMoveEnabled, setClickMoveEnabled] = useState(true);
        const [toast, setToast] = useState("");

        useEffect(()=>{ setNotes(loadNotes()); },[]);
        useEffect(()=>{ saveNotes(notes); },[notes]);

        useEffect(()=>{
          const onStorage = (e)=>{ if (e.key===LS_KEY && e.newValue){ try{ setNotes(JSON.parse(e.newValue)); }catch{} } };
          window.addEventListener("storage", onStorage);
          return ()=>window.removeEventListener("storage", onStorage);
        },[]);

        // Wait for Maps
        useEffect(()=>{
          const t = setInterval(()=>{
            if (window.google?.maps){
              clearInterval(t);
              const fallback = {lat:41.9028,lng:12.4964};
              setCenter(fallback);
              const m = new google.maps.Map(mapRef.current,{center:fallback, zoom:14, streetViewControl:false, fullscreenControl:false, mapTypeControl:false});
              map.current = m;
              placesSvc.current = new google.maps.places.PlacesService(m);
              infoRef.current = new google.maps.InfoWindow();
              centerMarker.current = new google.maps.Marker({position:fallback, map:m, draggable:true});
              centerMarker.current.addListener("dragend", ()=> setCenter(centerMarker.current.getPosition().toJSON()));
              m.addListener("click",(e)=>{ if(!clickMoveEnabled) return; const pos=e.latLng.toJSON(); centerMarker.current.setPosition(pos); setCenter(pos); });
              if (isSecureContext && navigator.geolocation){
                navigator.geolocation.getCurrentPosition((pos)=>{
                  const c={lat:pos.coords.latitude,lng:pos.coords.longitude};
                  centerMarker.current?.setPosition(c); setCenter(c);
                },()=>{}, {enableHighAccuracy:true, timeout:10000, maximumAge:0});
              }
              setLoading(false);
            }
          },100);
          return ()=>clearInterval(t);
        },[clickMoveEnabled]);

        useEffect(()=>{
          if (!center || !map.current) return;
          map.current.setCenter(center);
          centerMarker.current?.setPosition(center);
          if (!circleRef.current){
            circleRef.current = new google.maps.Circle({center, radius, map:map.current, fillOpacity:0.06, strokeOpacity:0.5, clickable:false, zIndex:0});
          } else {
            circleRef.current.setCenter(center);
          }
        },[center]);
        useEffect(()=>{ if (circleRef.current) circleRef.current.setRadius(radius); },[radius]);

        // helper: ricalcola visibilità marker in base ai filtri correnti
        function updateMarkerVisibilityFor(id){
          const mk = markersRef.current[id];
          if (!mk) return;
          const flagged = !!notes[id]?.flagged;
          const meta = placeMetaRef.current[id] || {};
          let passesMissing = true;
          if (missingOnly) passesMissing = (meta.hasWebsite === false); // visibile solo se NON ha sito
          const visible = passesMissing && (!onlyPotential || flagged);
          mk.setVisible(visible);
        }
        function updateAllMarkersVisibility(){
          Object.keys(markersRef.current).forEach(updateMarkerVisibilityFor);
        }

        // recolor & visibility quando note/filtri cambiano
        useEffect(()=>{
          Object.entries(markersRef.current).forEach(([id, mk])=>{
            const place = results.find(r=>r.place_id===id) || placeIndexRef.current[id];
            if (!place) return;
            const main = (place.types||[]).find(t=>TYPE_COLORS[t]) || "_unknown";
            const color = getPlaceColor(place, main, notes[id]?.status);
            mk.setIcon(createIcon(color));
          });
          updateAllMarkersVisibility();
        },[notes, results, onlyPotential, missingOnly]);

        function applyLeadUpdate(placeId, partial){
          setNotes(prev=>{
            const base = prev[placeId] || { note:"", flagged:false, status:"todo" };
            const updated = {...base, ...partial};
            const next = {...prev, [placeId]: updated};
            saveNotes(next);
            const mk = markersRef.current[placeId];
            const plc = results.find(r=>r.place_id===placeId) || placeIndexRef.current[placeId] || {};
            const main = (plc.types||[]).find(t=>TYPE_COLORS[t]) || "_unknown";
            const color = getPlaceColor(plc, main, updated.status);
            if (mk) mk.setIcon(createIcon(color));
            // visibilità potrebbe cambiare (es. onlyPotential)
            updateMarkerVisibilityFor(placeId);
            return next;
          });
        }

        async function runSearch(){
          if (!placesSvc.current || !center) return;
          setFetching(true);
          // reset
          Object.values(markersRef.current).forEach(m=>m.setMap(null));
          markersRef.current = {};
          placeIndexRef.current = {};
          placeMetaRef.current = {}; // reset meta

          const all = [];
          const base = {location:center, radius:String(radius), keyword:query||undefined};
          const paged = (req)=> new Promise(res=>{
            placesSvc.current.nearbySearch(req, (r, status, pagination)=>{
              if (status===google.maps.places.PlacesServiceStatus.OK && r){
                all.push(...r);
                if (pagination && pagination.hasNextPage) setTimeout(()=>pagination.nextPage(), 300); else res();
              } else res();
            });
          });
          const types = selectedType==="all" ? PROSPECT_TYPES.map(t=>t.value) : [selectedType];
          for (const t of types) await paged({...base, type:t});

          const dedup = new Map(); for (const p of all){ if (p.place_id && !dedup.has(p.place_id)) dedup.set(p.place_id, p); }
          let arr = Array.from(dedup.values());

          const gm = map.current;
          arr.forEach(p=>{
            if (!p.geometry?.location || !p.place_id) return;
            placeIndexRef.current[p.place_id] = p;
            placeMetaRef.current[p.place_id] = { hasWebsite: null }; // sconosciuto finché non carichiamo i dettagli
            const main = (p.types||[]).find(t=>TYPE_COLORS[t]) || "_unknown";
            const color = getPlaceColor(p, main, (notes[p.place_id]||{}).status);
            const mk = new google.maps.Marker({map:gm, position:p.geometry.location, title:p.name, icon:createIcon(color), zIndex:1000});
            markersRef.current[p.place_id] = mk;
            mk.addListener("click", ()=>{ const pos=mk.getPosition(); if(pos){ gm.panTo(pos); if(gm.getZoom()<16) gm.setZoom(16);} openInfo(p.place_id); });
          });

          if (missingOnly){
            // Carichiamo i dettagli di tutti per capire chi NON ha sito.
            const filtered = [];
            for (const p of arr){
              const d = await fetchDetails(p.place_id);
              const hasWebsite = !!d?.website;
              placeMetaRef.current[p.place_id] = { hasWebsite };
              if (!hasWebsite){
                filtered.push({...p, website:d?.website});
              }
              // Aggiorna visibilità del marker appena noto l'esito
              updateMarkerVisibilityFor(p.place_id);
            }
            arr = filtered;
          } else {
            // Filtri non attivi sul sito → rendi tutto visibile secondo altri filtri
            Object.keys(markersRef.current).forEach(updateMarkerVisibilityFor);
          }

          setResults(arr);
          setFetching(false);
        }

        const detailsCache = useRef({});
        function fetchDetails(placeId){
          if (!placesSvc.current) return Promise.resolve(null);
          if (detailsCache.current[placeId]) return Promise.resolve(detailsCache.current[placeId]);
          return new Promise((resolve)=>{
            placesSvc.current.getDetails({placeId, fields:["name","formatted_address","website","international_phone_number","opening_hours","url","types","business_status"]},
              (res,status)=>{
                if (status===google.maps.places.PlacesServiceStatus.OK && res){
                  detailsCache.current[placeId]=res;

                  // NEW: aggiorna meta sito e visibilità
                  const hasWebsite = !!res.website;
                  placeMetaRef.current[placeId] = { hasWebsite };
                  updateMarkerVisibilityFor(placeId);

                  const mk = markersRef.current[placeId];
                  if (mk){
                    const plc = results.find(r=>r.place_id===placeId) || placeIndexRef.current[placeId];
                    const main=(plc?.types||[]).find(t=>TYPE_COLORS[t])||"_unknown";
                    const color=getPlaceColor(res, main, (notes[placeId]||{}).status);
                    mk.setIcon(createIcon(color));
                  }
                  resolve(res);
                } else resolve(null);
              }
            );
          });
        }

        function messageText(place){
          const name = place?.name || "la tua attività";
          return `Ciao! 👋 Sono Federico di Visionary Web Forge.
Ho notato che ${name} potrebbe aumentare visibilità e clienti con un sito moderno o un e-commerce.
Ti va se ti invio un’idea gratuita e personalizzata (senza impegno) per mostrarti come distinguerti dai concorrenti? 🚀`;
        }

        async function openInfo(placeId){
          const place = results.find(r=>r.place_id===placeId) || placeIndexRef.current[placeId];
          if (!place || !place.geometry?.location) return;
          const details = await fetchDetails(placeId);
          const n = notes[placeId] || { note:"", flagged:false, status:"todo" };
          const radioName = `leadstatus_${placeId}`;
          const baseMsg = messageText(place);
          const waLink = buildWhatsAppLink(details?.international_phone_number || "", baseMsg + "\n\n— Federico, Visionary Web Forge");
          const mailLink = buildMailtoLink("", `Proposta per ${place?.name || 'la tua attività'}`, baseMsg + "\n\nUn saluto,\nFederico – Visionary Web Forge");

          const content = document.createElement("div");
          content.className="w-80 p-1";
          content.innerHTML = `
            <div class="font-semibold text-sm mb-1">${place.name || "Senza nome"}</div>
            <div class="text-xs text-gray-600 mb-2">${details?.formatted_address || ""}</div>
            ${details?.website ? `<a class="text-xs underline" target="_blank" rel="noopener" href="${details.website}">Visita sito</a>` : `<span class="text-xs font-medium">Nessun sito web</span>`}
            ${details?.international_phone_number ? `<div class="text-xs mt-1">☎️ ${details.international_phone_number}</div>` : ""}
            ${details?.business_status ? `<div class="text-xs mt-1">Stato: ${statusToLabel(details.business_status)}</div>` : ""}

            <div class="mt-2 grid grid-cols-2 gap-2">
              <a class="btn text-center" target="_blank" rel="noopener" href="${waLink}">WhatsApp</a>
              <a class="btn text-center" href="${mailLink}">Email</a>
            </div>

            <hr class="my-2" />
            <div class="text-xs mb-1 font-medium">Stato lead</div>
            <div class="grid grid-cols-2 gap-1 text-xs tick-group" id="status-group">
              ${Object.entries(LEAD_STATUS_LABEL).map(([k,label])=>`
                <label>
                  <input class="tick-radio" type="radio" name="${radioName}" value="${k}" ${n.status===k?"checked":""}/>
                  <span class="tick-box" style="border-color:${LEAD_STATUS_COLOR[k]};"></span>
                  <span>${label}</span>
                </label>
              `).join("")}
            </div>
            <label class="text-xs block mt-2 mb-1">Annotazioni</label>
            <textarea id="note" class="w-full border rounded p-2 text-xs" rows="3" placeholder="Note commerciali...">${(n.note||"").replace(/</g,"&lt;")}</textarea>
            <label class="flex items-center gap-2 mt-2 text-xs">
              <input id="flag" type="checkbox" ${n.flagged?"checked":""}/> Potenziale cliente
            </label>
            <button id="save" class="mt-2 btn btn-primary">Salva</button>
          `;

          setTimeout(()=>{
            const noteEl = content.querySelector("#note");
            const flagEl = content.querySelector("#flag");
            const saveBtn = content.querySelector("#save");
            content.querySelectorAll(`input[name='${radioName}']`).forEach(el=>{
              el.addEventListener("change", (ev)=>{
                applyLeadUpdate(placeId, { status: ev.target.value });
              });
            });
            let timer=null;
            noteEl?.addEventListener("input", ()=>{
              if (timer) clearTimeout(timer);
              timer = setTimeout(()=> applyLeadUpdate(placeId, { note: noteEl.value }), 250);
            });
            flagEl?.addEventListener("change", ()=> applyLeadUpdate(placeId, { flagged: !!flagEl.checked }) );
            saveBtn?.addEventListener("click", ()=>{
              const selected = content.querySelector(`input[name='${radioName}']:checked`)?.value || (notes[placeId]?.status || "todo");
              applyLeadUpdate(placeId, { note: noteEl.value, flagged: !!flagEl.checked, status: selected });
              infoRef.current?.close();
            });
          },0);

          if (!infoRef.current) infoRef.current = new google.maps.InfoWindow();
          infoRef.current.setContent(content);
          infoRef.current.open(map.current, markersRef.current[placeId]);
        }

        // Stats
        const statsSnapshot = ()=>{
          const ids = Object.keys(notes);
          const overall = { total:ids.length, flagged:0 };
          Object.keys(LEAD_STATUS_LABEL).forEach(k=> overall[k]=0);
          ids.forEach(id=>{ const n = notes[id]||{}; if(n.flagged) overall.flagged++; overall[n.status||"todo"]++; });
          const visibleIds = results.filter(r=>markersRef.current[r.place_id]?.getVisible()!==false).map(r=>r.place_id);
          const view = { total:visibleIds.length, flagged:0 };
          Object.keys(LEAD_STATUS_LABEL).forEach(k=> view[k]=0);
          visibleIds.forEach(id=>{ const n=notes[id]||{}; if(n.flagged) view.flagged++; view[n.status||"todo"]++; });
          return {overall, view};
        };

        // Export/Import
        function exportAll(){
          try{
            const data = { app:"Visionary Web Forge – Local Leads Map", version:"v8", exportedAt:new Date().toISOString(), notes: loadNotes() };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = "visionary-web-forge-leads-backup.json";
            document.body.appendChild(a); a.click();
            setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1500);
          }catch(e){ alert("Esportazione non riuscita: " + (e?.message || e)); }
        }
        function onImportClick(){ fileInputRef.current?.click(); }
        function validateImported(obj){
          if (!obj || typeof obj!=="object") return "File non valido.";
          if (!obj.notes || typeof obj.notes!=="object") return "File privo di dati 'notes'.";
          const normalized = {};
          for (const [id, v] of Object.entries(obj.notes)){
            normalized[id] = {
              note: (v && typeof v.note==="string") ? v.note : "",
              flagged: !!(v && v.flagged),
              status: (v && typeof v.status==="string" && LEAD_STATUS_LABEL[v.status]) ? v.status : "todo"
            };
          }
          return normalized;
        }
        function handleFile(e){
          const file = e.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev)=>{
            try{
              const obj = JSON.parse(String(ev.target.result||"{}"));
              const validated = validateImported(obj);
              if (typeof validated === "string") throw new Error(validated);
              const replace = confirm("Vuoi SOSTITUIRE i dati correnti? OK = Sostituisci, Annulla = Unisci (merge).");
              const merged = replace ? validated : {...loadNotes(), ...validated};
              saveNotes(merged);
              setNotes(merged);
              setToast(replace ? "Dati importati (sostituiti)." : "Dati importati (uniti).");
              setTimeout(()=>setToast(""), 2500);
            }catch(err){
              alert("Import fallito: " + (err?.message || err));
            }finally{
              e.target.value="";
            }
          };
          reader.readAsText(file);
        }

        // UI
        return html`
          <div class="min-h-screen grid grid-cols-1 lg:grid-cols-[420px_1fr]">
            <aside class="p-4 border-r bg-white space-y-4">
              <h1 class="text-xl font-bold tracking-tight">Local Leads Map</h1>
              <p class="text-sm text-gray-600">Filtri smart, messaggi veloci, salvataggio automatico. I puntini cambiano colore in base allo stato.</p>

              <div class="space-y-3">
                <div>
                  <label class="block text-xs mb-1">Tipo di attività</label>
                  <select class="w-full border rounded px-2 py-1 text-sm" value=${selectedType} onChange=${e=>setSelectedType(e.target.value)}>
                    <option value="all">Tutte le categorie consigliate</option>
                    ${PROSPECT_TYPES.map(t=> html`<option key=${t.value} value=${t.value}>${t.label}</option>`)}
                  </select>
                </div>
                <div>
                  <label class="block text-xs mb-1">Raggio (metri)</label>
                  <input class="w-full" type="range" min="300" max="8000" step="100" value=${radius} onInput=${e=>setRadius(+e.target.value)} />
                  <div class="text-xs text-gray-700 mt-1">${radius} m</div>
                </div>
                <div class="flex items-center justify-between gap-2">
                  <label class="flex items-center gap-2 text-xs"><input type="checkbox" checked=${clickMoveEnabled} onChange=${e=>setClickMoveEnabled(e.target.checked)} /> Sposta area con clic</label>
                  <button class="btn" onClick=${async()=>{
                    try{
                      if (!isSecureContext) throw new Error("Serve HTTPS per la geolocalizzazione.");
                      const pos = await new Promise((res,rej)=>navigator.geolocation.getCurrentPosition(res,rej,{enableHighAccuracy:true,timeout:10000,maximumAge:0}));
                      const c = {lat:pos.coords.latitude, lng:pos.coords.longitude};
                      centerMarker.current?.setPosition(c); setCenter(c);
                    }catch(e){ alert(e?.message || "Geolocalizzazione non disponibile."); }
                  }}>Usa mia posizione</button>
                </div>
                <div>
                  <label class="block text-xs mb-1">Cerca (parola chiave)</label>
                  <input class="w-full border rounded px-2 py-1 text-sm" value=${query} onInput=${e=>setQuery(e.target.value)} placeholder="es. pizza, parrucchiere, ferramenta..." />
                </div>
                <div class="flex flex-col gap-2 text-xs">
                  <label class="flex items-center gap-2"><input type="checkbox" checked=${missingOnly} onChange=${e=>setMissingOnly(e.target.checked)} /> Mostra solo attività <strong>senza</strong> sito web</label>
                  <label class="flex items-center gap-2"><input type="checkbox" checked=${onlyPotential} onChange=${e=>setOnlyPotential(e.target.checked)} /> Mostra solo <strong>potenziali clienti</strong></label>
                </div>
                <button class="w-full py-2 rounded btn btn-primary disabled:opacity-60" disabled=${loading||fetching||!center} onClick=${runSearch}>${fetching?"Ricerca in corso...":"Cerca nelle vicinanze"}</button>

                <div>
                  <div class="section-title">Backup</div>
                  <div class="flex items-center gap-2 flex-wrap">
                    <button class="btn" onClick=${exportAll}>Esporta dati (JSON)</button>
                    <button class="btn" onClick=${onImportClick}>Importa dati (JSON)</button>
                    <input ref=${fileInputRef} onChange=${handleFile} type="file" accept="application/json,.json" class="hidden" />
                  </div>
                  <p class="text-[11px] text-gray-500 mt-1">Import unisce o sostituisce i dati (ti verrà chiesto). Il file deve contenere <code>notes</code>.</p>
                </div>
              </div>

              <div>
                <h2 class="text-sm font-semibold mt-4 mb-2">Risultati (${results.length})</h2>
                <div class="space-y-2 max-h-[40vh] overflow-auto pr-1">
                  ${results
                    .map(r=> ({ id:r.place_id, name:r.name||"Senza nome", status:(notes[r.place_id]?.status)||"todo", flagged:!!notes[r.place_id]?.flagged }))
                    .filter(x=> !onlyPotential || x.flagged)
                    .sort((a,b)=>({ appointment:0, proposal_sent:1, quote_rejected:2, todo:3, in_progress:4, won:5, not_needed:6, not_interested:7, done:8 }[a.status]-({ appointment:0, proposal_sent:1, quote_rejected:2, todo:3, in_progress:4, won:5, not_needed:6, not_interested:7, done:8 }[b.status])))
                    .map(l=> html`
                      <div key=${l.id} class="card">
                        <div class="flex items-center justify-between gap-2">
                          <div class="font-medium truncate" title=${l.name}>${l.name}</div>
                          <span class="chip">${LEAD_STATUS_LABEL[l.status]}</span>
                        </div>
                        <div class="mt-2 flex gap-2">
                          <button class="btn" onClick=${()=>{ const mk=markersRef.current[l.id]; const pos=mk?.getPosition?.(); if(mk&&pos){ map.current?.panTo(pos); map.current?.setZoom(16); openInfo(l.id);} }}>Apri scheda</button>
                        </div>
                      </div>
                    `)
                  }
                  ${results.length===0 && html`<div class="text-xs text-gray-500">Nessun risultato. Premi "Cerca nelle vicinanze".</div>`}
                </div>
              </div>
            </aside>

            <div class="relative flex flex-col">
              <div ref=${mapRef} class="w-full h-[65vh] lg:h-[72vh]"></div>
              ${(()=>{ const s = (function(){ const ids = Object.keys(notes); const overall = { total:ids.length, flagged:0 }; Object.keys(LEAD_STATUS_LABEL).forEach(k=> overall[k]=0); ids.forEach(id=>{ const n = notes[id]||{}; if(n.flagged) overall.flagged++; overall[n.status||"todo"]++; }); const visibleIds = results.filter(r=>markersRef.current[r.place_id]?.getVisible()!==false).map(r=>r.place_id); const view = { total:visibleIds.length, flagged:0 }; Object.keys(LEAD_STATUS_LABEL).forEach(k=> view[k]=0); visibleIds.forEach(id=>{ const n=notes[id]||{}; if(n.flagged) view.flagged++; view[n.status||"todo"]++; }); return {overall, view}; })(); return html`
                <div class="w-full border-t bg-white/80 backdrop-blur p-4">
                  <h2 class="text-sm font-semibold mb-2">Statistiche</h2>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div class="card">
                      <div class="text-xs font-medium mb-1">Nell'area (filtri attivi)</div>
                      <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        <div class="stat"><span>Totale</span><strong>${s.view.total}</strong></div>
                        <div class="stat"><span>Potenziali</span><strong>${s.view.flagged}</strong></div>
                        ${Object.keys(LEAD_STATUS_LABEL).map(k=> html`<div class="stat" key=${"v_"+k}><span>${LEAD_STATUS_LABEL[k]}</span><strong>${s.view[k]}</strong></div>`)}
                      </div>
                    </div>
                    <div class="card">
                      <div class="text-xs font-medium mb-1">Complessivo (dispositivo)</div>
                      <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        <div class="stat"><span>Totale</span><strong>${s.overall.total}</strong></div>
                        <div class="stat"><span>Potenziali</span><strong>${s.overall.flagged}</strong></div>
                        ${Object.keys(LEAD_STATUS_LABEL).map(k=> html`<div class="stat" key=${"o_"+k}><span>${LEAD_STATUS_LABEL[k]}</span><strong>${s.overall[k]}</strong></div>`)}
                      </div>
                    </div>
                  </div>
                </div>`; })()}
              ${toast && html`<div class="absolute bottom-4 right-4 bg-black text-white text-xs px-3 py-2 rounded">${toast}</div>`}
            </div>
          </div>
        `;
      }

      const root = document.getElementById('root');
      function mount(){ render(html`<${App}/>`, root); }
      mount();
      // RIMOSSO: setInterval(mount, 1200);
    </script>
  </body>
</html>
